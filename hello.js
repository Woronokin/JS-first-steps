//Все подсказки здесь созданы для себя, которые будут корректироваться в ходе обучения.
//На корректность кода в данном файле не претендую!

console.log('Hello!');
// добавлена скрытая строка
/* скрытие для бодьших текстов или кусков кода */
console.log('This is my first steps in JavaScript');

//вывод переменных
var name; //объявление переменной (1 способ) - есть еще let и const
name = 'Woronokin'; //присваивание 
console.log(name); //вывод переменной
var	name = 'Philipp' //присваиваем другое значение переменной
console.log(name); //вывод переменной
var greeting = 'Hello' + ' ' + 'World'; //склеивание строк - коекатенация (2 способ)
console.log(greeting); //вывод  переменной
var greeting = 'Hello'; 
greeting += ' World'; // альтернатива greeting = greeting + ' World!'; (3 способ)
console.log(greeting);

2+2  // Сложение
10-8 // Вычитание
24*4 // Умножение
60/5 // деление
60%7 // остаток от деления

1>2  // больше
2<3  // меньше
5>=6 // больше или равно
6<=7 // меньше или равно
8==8 // равно - Boolean true (сравнение: == , присваивание: = . Не путать)
9!=10 // не равно - Boolean false

/* условный переход - цепочка условий */
var n = 17 // какое-то число
if (n == 0) {
	console.log(n + ' - равно нулю');
} else if (n > 0) { // еще одно условие
	console.log(n + ' - положительное число'); // альтернативная ветвь
} else {
	console.log(n + ' - отрицательное число');
}

// сокращенный способ
var message = (n > 0) ? 
	(" - положительное число") : (" - неположительное число");
console.log(n + message);

/* switch - оператор перехода по сопоставлению. Нельзя задать доп. условие и использует точное сопостоваление
Конструкция switch заменяет собой сразу несколько if.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами. */
var weekday = 'суббота'	// день недели
switch (weekday) {
	case 'понедельник':
	case 'вторник':
	case 'среда':
	case 'четверг':
	case 'пятница':
		console.log(weekday + ' Рабочий день');
		break; // нельзя забывать
	case 'суббота':
	case 'воскресенье':
		console.log(weekday + ' Выходной день');
		break;
	default: // необязательный блок
		console.log(weekday + ' Неизвестный день');
}

/* while - цикл с предусловием (до тех пор пока)
Для многократного повторения одного участка кода предусмотрены циклы.
*/

var n = 10;
while (n > 0) { //цикл выполняется, пока значение n > 0 истинно
	console.log(n);
	n -= 1; // можно еще записать так: n--;
}

/* while (true) {
	console.log{n}
} // бесконечный цикл */

/* do ... while - цикл с постусловием (делать до тех пор пока) */
var n = 10;
do {
	console.log(n);
	n -= 1;
} while (n > 0);
// похож на while(...){...}, но блок выполняется минимум 1 раз 
// сначала выполняется действие (do) , затем идет проверка (while)

/* for - цикл с параметром (для [всех значений])
выполнить начало - инициализация (присвоим переменной i значение 0)
 - условие завершения (пока i < 3)
 - продвижение (прибавлять единицу к i в конце каждого шага) */
for (var i=0; i < 3; i++) {
	console.log(i);
}

// интерация - 1 выполнение блока цикла, в примере 3 интерации

/* for (;;) {} //еще более простой способ бесконечного цикла */


/* string
'\n' // перенос строки
'\t' // знак табуляции
'\'' // одинарная кавычка
'\"' // двойная кавычка
'\uXXXX' // символ юникод, где XXXX это 16-ричный код символа

// boolean
// к строке
true + '' // 'true'
true.toString() // 'true'
// из строки
str == 'true'

// number	
100500 // целые числа
0.5 // десятичные дроби
.5 // можно опустить 0
1 / 3 // периодические дроби
123e10 //1230000000000
Math.exp(1) // 2.71821828459045
NaN // not-a-number (не число)
+Infinity // положительная бескончность
-Infinity // отрицательная бесконечность
// к строке
'' + 5 // '5'
5..toString() // '5'
// из строки
parseInt('5') // 5
parseInt('Hi!') // NaN


//Symbol - для символов 
let sym = Symbol("name")

// undefined - если переменная создана, но ей ничего не присвоено
// null - переменная не задана
// null == undefined //true

/*объекты - коллекция данных или структура,
куда можно положить любую информацию .
информация (свойства объекта) записывается так - ключ : значение, - через запятую*/


let user = {
	username : "Philipp", // свойства объекта
	age : 24,
	human : true,
	"favourite music band" : "BEP",
	// функция объекта (метод)
	breathe : function(){ 
		console.log("I am alive!")
	}
}

console.log(user);
// значение определенного свойства выводится так:
console.log(user.age); // через точку
console.log(user['age']); // через [] - необходимы '', свойство "favourite music band" выводится только с []


/* массив - это разновидность объектов, в котором используются [] и все данные идут через запятую,
каждому значению присваивается номер, начинается нумерация с 0 */

let arr = ["zero", "first", "second"];

console.log(arr[0]);
console.log(arr[1]);
console.log(arr[2]);

// typeof - оператор определения типа данных
// Если 2 раза написать typeof к любому типу данных - выведется string. (Иногда спрашивают на собеседованиях)
console.log(typeof{});
console.log(typeof[]);
console.log(typeof 0);
console.log(typeof false);
console.log(typeof "string");
console.log(typeof undefined);
console.log(typeof Symbol());
console.log(typeof null); // ошибка признанная официально

// Функция — это именованный фрагмент кода, к которому можно обратиться из другого места программы.
function sayHello(newname) {
	console.log('Hello, %s!' , newname); 
}; /* Функция может принимать произвольное количество аргументов,
	 которые передаются в нее в момент вызова. */

sayHello("Alice"); // выводим функцию

var student = "James";

// глобальная переменная
function changeName() {
	student = "Ivan";
};
changeName();
console.log(student);

// Функция также может вернуть результат
// вычислений с помощью return

function sum(a, b) {
	return a+b;
}

console.log(sum(4,5));
console.log(sum(789,11875));

// современный стандарт функции через =>
// функция короче, а результат тот же

let calc = (a, b) => a + b;
console.log(sum(4,5));
console.log(typeof calc());

/* анонимная функция - имя функции можно опустить,
если объявление фукнции является частью
другого оператора (например, вызова или присваивания) */

[1,2,3].map(function(i) { return i + 1 }); 
// Здесь в функцию map передается анонимная функция,
// которая вызывается для каждого элемента массива.

/* Функция как аргумент - sayHelloAsync, закончив свою основную работу
вызывает переданную функцию cb (от callback - функция обратного вызова) */
function sayHelloAsync(name2, cb) {
 
	console.log('Hello, %s!' , name2);
	cb() 
}

sayHelloAsync("Alice", function() {
	console.log("How are you?")
});

var alice = {
  name: 'Alice',
  age: 26,
  getProfile: function() {
    return this.name + ', age ' + this.age;
  }
};

var bob = {
  name: 'Bob',
  age: 31
};

var profile = alice.getProfile.call(bob);

console.log(profile);